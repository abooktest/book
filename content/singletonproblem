싱글톤 문제

안드로이드 앱 작성시에는 싱글톤 남용이 쉽습니다. 각 액티비티나 여러 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 생성하여 어디서나 접근하도록 설계할 수 밖에 없기 때문입니다.

제가 참여했던 프로젝트의 경우 싱글톤 클래스가 무려 100개가 넘었습니다 (전체 클래스 개수가 6000개가 넘는 프로젝트이긴 했습니다).

여러분들의 프로젝트의 싱글톤 클래스가 몇 개 인지 한번 세어보세요. 그리고, 그 중 몇 개의 클래스에 Manager라는 단어가 들어가는지도요.

 
싱글톤 클래스의 사용 이유를 살펴보면 다음과 같습니다.

–      편한 글로벌 액세스 제공

–      앱이 처음 실행될 때나 처음 액세스시에 생성되므로 객체 생성 시간이 적음

–      단일 인스턴스의 보장

 

싱글톤의 장점이라고 한다면, 글로벌 액세스 포인트를 제공하기 때문에 어디서나 쉽게 접근이 가능하다라는 점이 있고, 한번만 생성해 놓고 계속 사용하기 때문에 두번째 이용시부터는 객체 로딩 시간이 현저하게 줄어든다는 것이 있습니다.

그리고 단일 인스턴스를 보장한다는 점이 있고, 그 때문에 항상 생성된 객체를 재활용하므로 클래스 상태가 앱 생명주기 동안 그대로 유지됩니다.

예를 들어, 로그를 남기는 Log라는 클래스라던가, 연결 인스턴스를 재활용하는 ConnectionPool이라던가, 앱 라이프사이클을 통털어 상태를 관리하고자 하는 StateManager 같은 것들이 싱글톤의  예 일 수 있을 것 같습니다.

 

하지만 단점은 다음과 같습니다.

–      객체 지향 설계 원칙인 “개방-폐쇄 원칙” 에 위배되는 경우가 많음

–      커플링이 심해지고 수정하기 어려워 짐 (circular dependency)

–      테스트 하기 어려워짐

–      쓰레드에서 접근하는 경우 concurrency 문제 발생할 수 있음

–      한번 사용하면 앱 종료시 까지 메모리에 상주 (가비지 컬렉팅이 안됨)

 

객체 지향 설계 원칙인 SOLID를 기억하시나요? 로버트 마틴이라는 사람이 십수년전에 5개의 설계 원칙의 앞글자를 따서 만든 법칙인데요, 이 중에 4개 정도는 인터페이스 설계를 잘하라라는 내용과 관계 있습니다.

인터페이스라는 것은 간단하게 말하자면 어떤 메소드를 포함한다라는 계약을 프로그래밍 언어적으로 명세해 놓은 것이죠. 즉, 컴파일러 레벨에서의 의존성을 컨크리트 클래스에 두는 것이 아닌 인터페이스에 둠으로써, 실제 컨크리트 클래스의 구현 변경에서 대해서는 어느정도 해방되고자 하는 것입니다.

개방-폐쇄 원칙이란 open for extension, closed for modification 인데, 확장은 용이해야하고 수정은 가급적 하지 않도록 하자는 원칙입니다.

결국, 인터페이스를 활용하여 설계를 하여야 컨크리트 수정시에 영향을 받지 않고, 인터페이스는 유지한채로 다양한 확장 (내부 구현 방식에의 확장, 추가 기능 등의 확장)을 유연하게 해낼 수 있게 됩니다.

하지만, 싱글톤을 이용하는 경우는 대부분 싱글톤 클래스가 인터페이스가 아니라 직접 컨크리트 클래스에 getInstance()를 호출하여 사용하고, 그 싱글톤 클래스의 여러 메소드를 사용하므로써 의존성이 생기는 것이구요. 여기서 한발 더 나아가, 해당 싱글톤이 소유하고 있는 클래스 들까지 접근하여서 사용하기 때문에 문제는 더더 심각해집니다.

특히, Manager 류의 싱클톤 클래스는 문어발 처럼 다른 많은 클래스들을 또 다시 들고 있고, 그것을 타 클래스에 노출하기 때문에 Circular dependency가 복잡하게 생기게 되고, 결국 커플링이 심해져서 떼어낼 수 없는 모듈이 되어 버립니다.

이 것은 결국, 유닛 테스팅을 하기 어렵다는 뜻입니다.

 

어느 정도 큰 규모의 프로그램 개발시에는 ...Manager 같은 싱클톤 클래스는 피할 수는 없다고 봅니다. 여러 팀들이 공통으로 사용하는 모듈에 대해서 성능 향상을 위한 리소스 재활용한 경우도 있고, 모듈의 초기화 시점, 생성/삭제, 사용상의 편안함 등을 주장하면서 기능 제공을 요청하고 있어서 유용한 패턴인거지요. 그러나 그만큼 특별히 인터페이스를 관리하고 섬세하게 의존성을 관리하지 않는 한, 금새 복잡해지고 꼬이게 마련입니다.

다음과 같은 경우에 싱글톤 사용을 재고해봐야 합니다.

1) 단순히 전역 변수를 단순히 사용하기 위해서 싱글톤을 사용하는 경우. 

예를 들어, 단순히 헬퍼 메소드의 집합인 경우에는 싱글톤으로 하지 않고 정적 메소드를 제공하는 방향으로 전환해야 할 것이구요.

2) 의존성의 끝에 있는 객체들에서 사용하는 경우.글로벌 억세스를 표방한 싱글톤 클래스를 사용하더라도 굳이 싱글톤 클래스에 직접적으로 의존성을 두지 않으려면, 싱글톤 클래스에서 사용을 원하는 메소드만으로 인터페이스를 만들고, 사용을 원하는 클래스에는 의존 주입(Dependency Injection) 패턴을 이용하여, argument passing하게 처리하면 추후, 디커플링이나 테스트가 쉬워집니다.

3) 서브 클래싱하여 사용 가능한 경우.

또한 어떤 경우에는 싱글톤 클래스가 아니라, 상위 추상 클래스로 만들어 상속하여 쓰는 방법으로도 해결할 수 있습니다.

4) 싱글톤 클래스가 다른 문어발 클래스를 들고 있는 경우

싱글톤 클래스가 새로 생성하는 클래스들도 필요할 때 마다 생성해서 쓰는 방법으로 바꾸고, 팩토리 클래스를 두어서 싱글톤 클래스로 의존 주입(Dependency Injection)이 되로록 해야 할 것입니다.

@코드 예제와 그림 추가 고민
